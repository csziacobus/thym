(in-package #:thym)

(defexpr + (assoc-expr) ((identity :allocation :class
                                   :initform 0))
    (&rest args)
  (assoc-expr '+ args))

(defmethod deriv ((expr +) wrt &optional (n 1))
  (apply #'+ (mapcar (rcurry #'deriv wrt n) (args expr))))

(defmethod level ((expr +))
  (labels ((iter (args terms coeff &aux (arg (first args)))
             (cond
               ((null args) (values coeff terms))
               ((numberp arg)
                (iter (rest args) terms (cl:+ coeff arg)))
               ((typep arg '+)
                (iter (append (rest args) (args arg))
                        terms
                        coeff))
               (t (with-coeff-term (c term) arg
                    (setf (gethash term terms)
                          (let ((val (gethash term terms)))
                            (if val (cl:+ c val) c)))
                    (iter (rest args) terms coeff))))))
    (multiple-value-bind (coeff hash)
        (iter (args expr) (make-hash-table :test #'equals) 0)
      (let (new-args)
        (maphash (lambda (term coeff)
                   (cond
                     ((null term) (error "bad hash ~A" hash))
                     ((zero? coeff))
                     ((eql coeff 1) (push term new-args))
                     ((typep term '*)
                      (push (apply #'* coeff (args term)) new-args))
                     (t (push (* coeff term) new-args))))
                 hash)
        (string-sort (push coeff new-args))))))

(defmethod level ((expr +))
  (let ((args (args expr))
        (terms (make-hash-table :test #'equals))
        new-args
        (coeff 0))
    (push (first args) args)
    (do* ((%args args (rest (progn (pop args) args)))
          (arg (first %args) (first %args)))
         ((endp (rest args)))
      (let (c s)
        (cond
          ((numberp arg)
           (incf coeff arg))
          ((typep arg '+)
           (appendf args (args arg)))
          ((typep arg '*)
           (setf c (coefficient arg) s (number-free-term arg)))
          (t (setf c 1 s arg)))
        (unless (or (numberp arg)
                    (typep arg '+))
          (setf (gethash s terms)
                (if (gethash s terms)
                    (cl:+ (gethash s terms) c)
                    c)))))
    (maphash (lambda (s c)
               (cond
                 ((null s))
                 ((zero? c))
                 ((eql c 1)
                  (push s new-args))
                 ((typep s '*)
                  (push (func s (list* c (args s))) new-args))
                 (t
                  (push (* c s) new-args))))
             terms)
    (string-sort (push coeff new-args))))

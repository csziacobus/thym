(in-package #:thym)

(defexpr * (assoc-expr) ((identity :initform 1
                                   :allocation :class))
    (&rest args)
  (let ((expr (assoc-expr '* args)))
    (cond ((not (typep expr 'expr)) expr)
          ((member 0 (args expr)) 0)
          (t expr))))

(defmethod deriv ((expr *) wrt &optional (n 1))
  (let ((args (args expr)) factors)
    (dotimes (i (length args))
      (let ((term (deriv (nth i args) wrt n)))
        (unless (eql term 0)
          (push (apply #'* 
                       (append (nthcdr (1+ i) args)
                               (list term)
                               (subseq args 0 i)))
                factors))))
    (apply #'+ (nreverse factors))))

(defmethod level ((expr *))
  (labels ((iter (args terms coeff &aux (arg (first args)))
             (cond
               ((null args) (values coeff terms))
               ((numberp arg)
                (iter (rest args) terms (cl:* coeff arg)))
               ((typep arg '*)
                (iter (append (rest args) (args arg))
                      terms
                      coeff))
               (t (power-bind (base exponent) arg
                    (setf (gethash base terms)
                          (let ((val (gethash base terms)))
                            (if val (cl:+ exponent val) exponent)))
                    (iter (rest args) terms coeff))))))
    (multiple-value-bind (coeff hash)
        (iter (args expr) (make-hash-table :test #'equals) 1)
      (let (new-args)
        (maphash (lambda (base expo)
                   (print (list base expo))
                   (cond
                     ((null base) (error "bad hash ~A" hash))
                     ((zero? base) (push 0 new-args))
                     ((eql expo 1) (push base new-args))
                     ((eql expo 0))
                     ((eql base 1))
                     (t (push (^ base expo) new-args))))
                 hash)
        (string-sort (push coeff new-args))))))

(defmethod coefficient ((expr *))
  (let ((arg (first (args expr))))
    (if (number? arg)
        (values arg t)
        (values 1 nil))))

(defmethod number-free-term ((expr *))
  (let ((args (args expr)))
    (if (number? (first args))
        (apply #'* (rest args))
        expr)))

(defmacro with-coeff-term ((coefficient number-free-term) expr &body body)
  `(let ((,coefficient (coefficient ,expr))
         (,number-free-term (number-free-term ,expr)))
     ,@body))

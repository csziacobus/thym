(in-package #:thym)

(defexpr * (assoc-expr) ((identity :initform 1
                                   :allocation :class))
    (&rest args)
  (let ((expr (assoc-expr '* args)))
    (cond ((not (typep expr 'expr)) expr)
          ((member 0 (args expr)) 0)
          (t expr))))

(defmethod deriv ((expr *) wrt &optional (n 1))
  (let ((args (args expr)) factors)
    (dotimes (i (length args))
      (let ((term (deriv (nth i args) wrt n)))
        (unless (eql term 0)
          (push (apply #'*
                       (append (nthcdr (1+ i) args)
                               (list term)
                               (subseq args 0 i)))
                factors))))
    (apply #'+ (nreverse factors))))

(defmethod level ((expr *)) ; ver
  (let ((args (args expr))
        (terms (make-hash-table :test #'equals))
        (coeff 1) new-args)
    (push (first args) args)
    (do* ((%args args (rest (progn (pop args) args)))
          (arg (first %args) (first %args)))
         ((endp (rest args)))
      (let (b e)
        (cond
          ((numberp arg)
           (setf coeff (cl:* coeff arg)))
          ((typep arg '*)
           (appendf args (args arg))
           (setf b arg e 1))
          ((typep arg '^)
           (setf b (base arg) e (exponent arg)))
          ((typep arg 'exp)
           (setf b 'exp e (exponent arg)))
          (t (setf b arg e 1)))
        (unless (or (numberp arg)
                    (typep arg '*))
          (setf (gethash b terms)
                (if (gethash b terms)
                    (+ (gethash b terms) e)
                    e)))))
    (maphash (lambda (b e)
               (cond
                 ((zero? b) (push 0 new-args))
                 ((eql b 1))
                 ((eql e 1) (push b new-args))
                 ((eql b 'exp) (push (exp e) new-args))
                 (t (push (^ b e) new-args))))
             terms)
    (push coeff new-args)
    (string-sort new-args)))

(defmethod coefficient ((expr *))
  (let ((arg (first (args expr))))
    (if (number? arg)
        (values arg t)
        (values 1 nil))))

(defmethod number-free-term ((expr *))
  (let ((args (args expr)))
    (if (number? (first args))
        (apply #'* (rest args))
        expr)))

(defmacro with-coeff-term ((coefficient number-free-term) expr &body body)
  `(let ((,coefficient (coefficient ,expr))
         (,number-free-term (number-free-term ,expr)))
     ,@body))

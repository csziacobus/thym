;;;; tokenize.lisp

(in-package #:thym)

(define-string-lexer thym-tokens
  ("\\(" (return (values '|(| :lparen)))
  ("\\)" (return (values '|)| :rparen)))
  ("\\[" (return (values '|(| :lparen)))
  ("\\]" (return (values '|)| :rparen)))
  ("\\{" (return (values '|(| :lparen)))
  ("\\}" (return (values '|)| :rparen)))
  ("\\+" (return '+))
  ("\\-" (return '-))
  ("\\*" (return '*))
  ("/" (return '/))
  ("\\^" (return '^))
  ("\\i" (return #C (0 1)))
  ("pi" (return 'pi))
  ("Ï€" (return 'pi))
  ("e" (return '(exp 1)))
  ("\\," (return (values #\Space :space)))
  ("[A-Za-z_][A-Za-z0-9_\\-]+" (return (values (read-from-string $@) :op)))
  ("[A-Za-z_]" (return (values (read-from-string $@) :var)))
	("'[A-Za-z_]" (return (values (read-from-string $@) :var)))
  ("[0-9]*\\.?[0-9]+" (return (values (read-from-string $@) :number)))
  ("[ \\n\\t]+" #| ignore whitespace |#))

(defun tokenize (string)
  (do* ((token-generator (thym-tokens string))
				(token (multiple-value-list (funcall token-generator))
	       (multiple-value-list (funcall token-generator)))
				(value (first token) (first token))
				(tag (second token) (second token))
				prev-tag
				expr)
       ((not value)
				(read-from-string (format nil "~A" (nreverse expr))))
    (when (and (member prev-tag '(:number :var :rparen))
							 (member tag '(:op :var :lparen)))
      (push '* expr))
    (when (eq tag :op)
      (push '|(| expr))
    (unless (or (and (eq tag :lparen)
										 (eq prev-tag :op)))
      (push value expr))
    (setf prev-tag tag)))
